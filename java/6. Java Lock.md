# Java锁相关

## 1.简述锁的升级过程

Java中的锁升级是指Java虚拟机（JVM）为了优化锁的性能，采用的一种策略，它会根据锁的竞争情况，将锁的状态从轻量级锁升级到重量级锁。Java中的锁主要有以下几种状态：

1. **无锁状态**：对象刚被创建，还没有线程尝试获取它的锁。
2. **偏向锁**（Biased Locking）：当一个线程访问同步块并获取锁时，如果没有其他线程竞争，JVM就会把对象头中的一部分空间用来记录锁偏向的线程ID。以后该线程再次请求锁时，只需要检查对象头的偏向锁标记以及线程ID即可，避免了锁的竞争，提高了性能。如果有另一个线程尝试获取锁，偏向模式结束。
3. **轻量级锁**（Lightweight Locking）：当偏向锁失效后，如果有其他线程尝试获取锁，JVM会将锁升级为轻量级锁。轻量级锁通过在对象头上存储锁记录（Lock Record）的方式来实现同步。如果线程成功获取轻量级锁，它会在自己的栈帧中创建一个锁记录的空间，用来存储锁对象头的拷贝。当锁释放时，JVM只需要将这个拷贝和实际对象头进行比较，如果相同，表示没有竞争，锁可以被释放。
4. **重量级锁**（Heavyweight Locking）：当轻量级锁的竞争激烈时，为了减少线程之间的竞争，JVM会将锁升级为重量级锁。重量级锁通过操作系统的互斥量（Mutex）来实现，每个对象都关联一个监视器（Monitor），当多个线程尝试访问同步代码块时，未能获取锁的线程会被阻塞。

锁的升级路径是：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁。

锁的升级是一个单向过程，即锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，但是不能降级。这个设计是为了减少系统的复杂性和提高性能。每一种锁都是针对不同竞争情况下的优化，偏向锁适用于只有一个线程访问同步块的情况，轻量级锁适用于线程交替执行同步块的情况，而重量级锁适用于多个线程同时竞争同步块的情况。

## 2. wait和sleep哪个会释放锁？

wait和sleep都会释放资源，出让CPU时间，不同的是sleep不会释放锁，休眠一定时间后会继续执行；wait会释放锁资源，需要等待notify()或notifyAll()恢复重新获得锁执行；Sleep是线程静态方法，wait是对象方法。

## 3.简述线程池核心参数的执行流程

